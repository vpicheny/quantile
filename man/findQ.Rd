% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/findQ.R
\name{findQ}
\alias{findQ}
\title{Main solver}
\usage{
findQ(model, fun, alpha = 0.95, n.ite = 45, n = 1000, n.large = NULL,
  n.cluster = 1, seed = 42, n.candidates = NULL, Xdistrib = NULL,
  x = NULL, cov.reestim = TRUE)
}
\arguments{
\item{model}{an object of class km}

\item{fun}{the function of interest}

\item{alpha}{the quantile level}

\item{n.ite}{number of iterations (points to add)}

\item{n}{the number of points used for integration}

\item{n.large}{(optional) a larger number of points used prior to integration}

\item{n.cluster}{number of cores used (requires the libraries \code{forreach} and \code{doparallel})}

\item{seed}{the seed}

\item{n.candidates}{(optional) a smaller number of candidate points on which the criterion is computed}

\item{Xdistrib, x}{\code{Xdistrib} is a function that returns a sample of x given an integer, and x is a matrix (see details)}

\item{cov.reestim}{Boolean; if TRUE, the GP parameters are re-estimated at each iteration}
}
\value{
A list with all.qn (all the quantiles estimated) and model (the last km model)
}
\description{
Main function to find quantiles.
}
\details{
Either the distribution of the input \code{Xdistrib} or a sample x must be given. 
If x is given, the problem is treated as discrete.

In the standard setting, a large number of points (\code{n.large}) is generated using \code{Xdistrib}, out of which 
\code{n} useful integration points are selected. The SUR criterion is then evaluated at the most promising \code{n.candidates} 
points. Finally, a local optimization is performed using \code{BFGS} from the best candidate.

Maximum recommended values are 5,000 for \code{n}, 1e6 for \code{n.large} and 1,000 for \code{n.candidates}.
}
\examples{
\dontrun{
library(DiceDesign)
#--------------------------------------------------------#
# Set problem parameters
fun <- branin
d <- 2
n.init <- 6
n.ite <- 24
seed <- 42
n <- 2e3
#--------------------------------------------------------#
# Define distribution over the input X
mu <- rep(.5, d)
Sigma <- matrix(rep(.05, d*d), d,d)
diag(Sigma) <- .1
Xdistrib <- function(n) return(mvrnorm(n=n, mu=mu, Sigma))
#--------------------------------------------------------#
# Initial set of observations (rescaled to fit Xdistrib)
x.init <- lhsDesign(n.init, d, seed=seed)$design
x.init <- mu + qnorm(x.init) \%*\% chol(Sigma)
y.init <- as.numeric(apply(x.init, 1, fun))
#--------------------------------------------------------#
# Initial kriging model
model <- km(~., design=data.frame(x=x.init), response=y.init, 
            lower=rep(.05,d), upper=rep(1,d), control=list(trace=FALSE))
#--------------------------------------------------------#
# Sequential design
res <- findQ(model=model, fun=fun, alpha=.95, n.ite=n.ite, n=n, n.cluster=1, seed=seed, n.large=1e5,
             n.candidates=100, Xdistrib=Xdistrib, cov.reestim = TRUE)
#--------------------------------------------------------#
# Plot DoE and quantile estimates
plot(res$model@X[,1], res$model@X[,2])
plot(res$all.qn)
}

}
\references{
T. Labopin-Richard, V. Picheny, "Sequential design of experiments for estimating quantiles of black-box functions", 
Statistica Sinica, 2017, \emph{doi:10.5705/ss.202016.0160}
}
\author{
Victor Picheny
}
